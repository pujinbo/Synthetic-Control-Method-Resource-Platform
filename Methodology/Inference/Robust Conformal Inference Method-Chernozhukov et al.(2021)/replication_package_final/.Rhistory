overall_K2 <- c(overall_K2_15,overall_K2_150)
overall_K3 <- c(overall_K3_15,overall_K3_150)
print(DGP)
print(round(c(overall_K2_15[5]/overall_K2_15[4],overall_K3_15[5]/overall_K3_15[4]),digits=2))
print(round(c(overall_K2_150[5]/overall_K2_150[4],overall_K3_150[5]/overall_K3_150[4]),digits=2))
print(xtable(cbind(c(2,3),rbind(overall_K2,overall_K3)),digits=c(0,0,rep(2,12))),include.rownames = F)
}
#######################################################
# Application: Abadie and Gardeazabal (2003)
# Authors: V. Chernozhukov, K. Wuthrich, Y. Zhu
#######################################################
#######################################################
# Preliminaries
#######################################################
rm(list = ls())
library(xtable)
library(Synth)
library(scinference)
setwd("/Users/kasparwuthrich/Dropbox/research/SC/SC with Victor and Yinchu/Asymptotics Paper")
set.seed(12345)
#######################################################
# Data
#######################################################
### Data preparation
detach(basque)
data("basque")
attach(basque)
data.long <- as.data.frame(cbind(regionno,year,gdpcap))
data.wide <- reshape(data.long,dir="wide",idvar="regionno",timevar="year")
Y1 <- unlist(data.wide[17,-1])
Y0 <- t(matrix(unlist(data.wide[-c(1,17),-1]),16,43))
J <- dim(Y0)[2]
### Raw data plot
graphics.off()
time <- c(seq(1955,1997,1))
pdf("Paper/Graphics/basque_data_raw.pdf",pointsize=14,width=9.0,height=6.0)
plot(1, ylab="Per Capita GDP", xlab="Time", main="", col="blue", pch=".", xlim = range(time), ylim=c(1,13))
for (j in 1:dim(Y0)[2]) lines(time,Y0[,j],col="black",lwd=0.5,lty=1)
lines(time,Y1,col="black",lwd=5,lty=1)
legend("topleft",legend=c("Basque Country","Controls"), seg.len=2, col=c("black","black"),fill=NA,border=NA, lty=c(1,1),lwd=c(5,0.5), merge=T,bty="n")
dev.off()
### Pre-treatment period: 1955-1969; post-treatment period: 1970-1997
T0 <- 15
T1 <- length(Y1)-T0
T01 <- T0+T1
#######################################################
# Main results
#######################################################
alpha.sig <- 0.1
K.vec  <- c(2:3)
tau.sc.vec <- se.sc.vec <-  t.sc.vec <- lb.sc.vec <- ub.sc.vec <-  matrix(NA,length(K.vec),1)
for (k in 1:length(K.vec)){
r.sc.sim          <- scinference(Y1,Y0,T1=T1,T0=T0,inference_method="ttest",K=K.vec[k])
tau.sc.vec[k,1]   <- r.sc.sim$att
se.sc.vec[k,1]    <- r.sc.sim$se
t.sc.vec[k,1]     <- r.sc.sim$att/r.sc.sim$se
lb.sc.vec[k,1]    <- r.sc.sim$lb
ub.sc.vec[k,1]    <- r.sc.sim$ub
}
results.sc  <- cbind(tau.sc.vec,se.sc.vec,t.sc.vec,lb.sc.vec,ub.sc.vec)
round(results.sc,digits=3)
round(qt(1-alpha.sig/2,df=1),digits=2)
round(qt(1-alpha.sig/2,df=2),digits=2)
#####################################################################
# Empirical Monte Carlo based on Abadie and Gardeazabal (2003)
# Authors: V. Chernozhukov, K. Wuthrich, Y. Zhu
#####################################################################
#####################################################################
# Preliminaries
#####################################################################
rm(list = ls())
library(Synth)
library(xtable)
library(scinference)
set.seed(12345)
setwd("/Users/kasparwuthrich/Dropbox/research/SC/SC with Victor and Yinchu/Asymptotics Paper")
###################################################################
# Functions
###################################################################
source("Code/common_functions_001.R")
sim.one.sample <- function(DGP,T0,T1,J,K,Lambda,rho.u,var.u,var.factors,rho.vec,var.epsl.vec,w0.sc){
# Preliminaries
alpha.sig <- 0.1
# DGPs
if (DGP==1){ # SC (estimated)
w       <- w0.sc
nonstat <- matrix(0,(T0+T1),J)
}
if (DGP==2){ # DID
w       <- matrix(1,J,1)/J
nonstat <- matrix(0,(T0+T1),J)
}
if (DGP==3){ # Full misspecification
w       <- -matrix(seq(1,J,1),J,1)/J
nonstat <- matrix(0,(T0+T1),J)
}
if (DGP==4){ # Common deterministic trend
w       <- w0.sc
theta   <- c(1:(T0+T1))
nonstat <- matrix(rep(theta,J),(T0+T1),J)
}
if (DGP==5){ # Common random walk
w       <- w0.sc
theta   <- cumsum(rnorm((T0+T1)))
nonstat <- matrix(rep(theta,J),(T0+T1),J)
}
if (DGP==6){ # Common deterministic trend + sparse deviation
w           <- w0.sc
theta       <- c(1:(T0+T1))
nonstat     <- matrix(rep(theta,J),(T0+T1),J)
deviation   <- c(1:(T0+T1))
nonstat[,1] <- nonstat[,1] + deviation # note that the first element of w0.sc is zero.
}
if (DGP==7){ # Common random walk + sparse deviation
w           <- w0.sc
theta       <- cumsum(rnorm((T0+T1)))
nonstat     <- matrix(rep(theta,J),(T0+T1),J)
deviation   <- cumsum(rnorm((T0+T1)))
nonstat[,1] <- nonstat[,1] + deviation # note that the first element of w0.sc is zero.
}
if (DGP==8){ # Heterogenous deterministic trends
w       <- w0.sc
nonstat <- matrix(NA,(T0+T1),J)
for (j in 1:J){
nonstat[,j] <- j+j*c(1:(T0+T1))
}
}
if (DGP==9){ # Random walks with heterogenous drifts
w       <- w0.sc
nonstat <- matrix(NA,(T0+T1),J)
for (j in 1:J){
theta     <- rep(NA,(T0+T1))
wn        <- rnorm((T0+T1))
theta[1]  <- wn[1]
for (t in 2:(T0+T1)){
theta[t] <- j+theta[(t-1)] + wn[t]
}
nonstat[,j] <- theta
}
}
# Generate T01
T01 <- (T0+T1)
# Generate errors as AR(1)
u.sim <- generate.AR.series.var.input(T01,rho.u,var.u)
# Generate iid factors
Factors.sim <- matrix(NA,T01,num.factor)
for (i in 1:num.factor){
Factors.sim[,i] <- rnorm(T01)*sqrt(var.factors[i])
}
# Generate control errors as AR(1)
epsl.sim <- matrix(NA,T01,J)
for (i in 1:J){
epsl.sim[,i] <- generate.AR.series.var.input(T01,rho.vec[i],var.epsl.vec[i])
}
# Linear model (under the null of no effect)
Y0 <- nonstat + Factors.sim %*% t(Lambda) + epsl.sim
Y1 <- Y0 %*% w + u.sim
# Results
r.sc.sim    <- scinference(Y1,Y0,T1=T1,T0=T0,inference_method="ttest",K=K)
tau.hat.sc  <- r.sc.sim$att
se.hat.sc   <- r.sc.sim$se
cov.sc.vec  <- (abs(tau.hat.sc/se.hat.sc)<=qt(1-alpha.sig/2,df=K-1))
leng.sc.vec <- 2*qt(1-alpha.sig/2,df=K-1)*se.hat.sc
r.did.sim     <- scinference(Y1,Y0,T1=T1,T0=T0,inference_method="ttest",estimation_method="did",K=K)
tau.hat.did   <- r.did.sim$att
se.hat.did    <- r.did.sim$se
cov.did.vec   <- (abs(tau.hat.did/se.hat.did)<=qt(1-alpha.sig/2,df=K-1))
leng.did.vec  <- 2*qt(1-alpha.sig/2,df=K-1)*se.hat.did
w.true          <- w
r.oracle.sim    <- oracle.cf(Y1,Y0,T0,T1,w.true,K)
tau.hat.oracle  <- r.oracle.sim$tau.hat
se.hat.oracle   <- r.oracle.sim$se.hat
cov.oracle.vec  <- (abs(tau.hat.oracle/se.hat.oracle)<=qt(1-alpha.sig/2,df=K-1))
leng.oracle.vec <- 2*qt(1-alpha.sig/2,df=K-1)*se.hat.oracle
length.all    <- c(leng.sc.vec,leng.did.vec,leng.oracle.vec)
coverage.all  <- c(cov.sc.vec,cov.did.vec,cov.oracle.vec)
result        <- c(coverage.all,length.all)
return(result)
}
###################################################################
# Calibration to application
###################################################################
data("basque")
attach(basque)
data.long <- as.data.frame(cbind(regionno,year,gdpcap))
data.wide <- reshape(data.long,dir="wide",idvar="regionno",timevar="year")
# Raw data
Y1 <- unlist(data.wide[17,-1])
Y0 <- t(matrix(unlist(data.wide[-c(1,17),-1]),16,43))
J <- dim(Y0)[2]
### Pre-treatment period: 1955-1969; post-treatment period: 1970-1997
T0 <- 15
T1 <- length(Y1)-T0
T01 <- T0+T1
### De-trend data
bX <- rowMeans(Y0)
Y1dt <- Y1-bX
Y0dt <- apply(Y0,2,function(x) x - bX)
### Fit factor model
w0.sc         <- as.matrix(sc(Y1dt[1:T0],Y0dt[1:T0,]))
u.hat         <- Y1dt[1:T0] - Y0dt[1:T0,] %*% w0.sc
ar.obj.u.hat  <- ar(u.hat, order.max=1)
rho.u         <- ar.obj.u.hat$ar
var.u         <- ar.obj.u.hat$var.pred # this is the variance of the AR error term
result <- svd(Y0dt)
max(abs(result$u %*% diag(result$d) %*% t(result$v)-Y0dt))
num.factor            <- 4
dd                    <- result$d
dd[(num.factor+1):J]  <- 0
Y0.PCA.est            <- result$u %*% diag(dd) %*% t(result$v)
Y0.resid              <- Y0dt-Y0.PCA.est
Factors <- result$u[,1:num.factor]
Lambda  <- result$v %*% diag(dd)
Lambda  <- Lambda[,1:num.factor]
var.factors <- matrix(NA,num.factor,1)
for (j in 1:num.factor){
var.factors[j]  <- var(Factors[,j])
}
rho.vec       <- matrix(NA,J,1)
var.epsl.vec  <- matrix(NA,J,1)
for (j in 1:J){
ar.obj          <- ar(Y0.resid[,j], order.max=1)
rho.vec[j,1]    <- ar.obj$ar
var.epsl.vec[j] <- ar.obj$var.pred
}
round(w0.sc,digits=2)
round(rho.u,digits=2)
round(c(min(rho.vec),max(rho.vec),median(rho.vec)),digits=2)
#######################################################
# Simulations
#######################################################
nreps     <- 5000
for (DGP in 1:9){
results_K2_15 <- results_K3_15 <- results_K2_150 <- results_K3_150 <- matrix(NA,nreps,6)
for (r in 1:nreps){
results_K2_15[r,]   <- sim.one.sample(DGP,15,T1,J,2,Lambda,rho.u,var.u,var.factors,rho.vec,var.epsl.vec,w0.sc)
results_K3_15[r,]   <- sim.one.sample(DGP,15,T1,J,3,Lambda,rho.u,var.u,var.factors,rho.vec,var.epsl.vec,w0.sc)
results_K2_150[r,]  <- sim.one.sample(DGP,150,T1,J,2,Lambda,rho.u,var.u,var.factors,rho.vec,var.epsl.vec,w0.sc)
results_K3_150[r,]  <- sim.one.sample(DGP,150,T1,J,3,Lambda,rho.u,var.u,var.factors,rho.vec,var.epsl.vec,w0.sc)
}
overall_K2_15   <- colMeans(results_K2_15)
overall_K3_15   <- colMeans(results_K3_15)
overall_K2_150  <- colMeans(results_K2_150)
overall_K3_150  <- colMeans(results_K3_150)
overall_K2 <- c(overall_K2_15,overall_K2_150)
overall_K3 <- c(overall_K3_15,overall_K3_150)
print(DGP)
print(round(c(overall_K2_15[5]/overall_K2_15[4],overall_K3_15[5]/overall_K3_15[4]),digits=2))
print(round(c(overall_K2_150[5]/overall_K2_150[4],overall_K3_150[5]/overall_K3_150[4]),digits=2))
print(xtable(cbind(c(2,3),rbind(overall_K2,overall_K3)),digits=c(0,0,rep(2,12))),include.rownames = F)
}
###########################################################################################################
# Stylized simulation to illustrate the importance of imposing the null
# Paper: An exact and robust conformal inference approach for counterfactual and synthetic controls
# Authors: V. Chernozhukov, K. Wuthrich, Y. Zhu
# DISCLAIMER: This software is provided "as is" without warranty of any kind, expressed or implied.
# Questions/error reports: kwuthrich@ucsd.edu
###########################################################################################################
###########################################################################################################
# Preliminaries
###########################################################################################################
rm(list = ls())
setwd("/Users/kasparwuthrich/Dropbox/research/SC/SC with Victor and Yinchu/Conformal Paper/Code/replication_package_final")
set.seed(12345)
### Functions
source("functions_conformal_final.R")
###########################################################################################################
# Additional functions
###########################################################################################################
generate.AR.series <- function(T01,rho){
u           <- rep(NA,T01)
epsl        <- rnorm(T01)*sqrt(1-rho^2)
startvalue  <- rnorm(1)
u[1]        <- rho*startvalue + epsl[1]
for (t in 2:T01){
u[t] <- rho*u[(t-1)]+epsl[t]
}
return(u)
}
sc.nonull <- function(Y1,Y0){
T0    <- length(Y1)-1
Y1est <- Y1[1:T0]
Y0est <- Y0[1:T0,]
w.hat <- sc(Y1est,Y0est)$w.hat
u.hat <- Y1 - Y0 %*% w.hat
return(u.hat)
}
sc.null <- function(Y1,Y0){
w.hat <- sc(Y1,Y0)$w.hat
u.hat <- Y1 - Y0 %*% w.hat
return(u.hat)
}
sim <- function(T0,J,alpha.sig,rho){
T01     <- T0 + 1
Y0      <- matrix(rnorm((J)*T01),T01,J)
w       <- matrix(0,J,1)
w[1:3]  <- 1/3
Y1 <- Y0%*%w + generate.AR.series(T01,rho)
u.nonull  <- sc.nonull(Y1,Y0)
p.nonull  <- mean(abs(u.nonull)>=abs(u.nonull[T0+1]))
u.null    <- sc.null(Y1,Y0)
p.null    <- mean(abs(u.null)>=abs(u.null[T0+1]))
rej.null    <- (p.null<=alpha.sig)
rej.nonull  <- (p.nonull<=alpha.sig)
return(cbind(rej.null,rej.nonull))
}
###########################################################################################################
# Simulations
###########################################################################################################
nreps     <- 100000
alpha.sig <- 0.1
T0        <- 19
J         <- 50
rho.vec   <- c(seq(0.0,0.9,0.1),0.95)
results.overall <- matrix(NA,length(rho.vec),2)
for (r in 1:length(rho.vec)){
rho     <- rho.vec[r]
results <- matrix(NA,nreps,2)
for (rep in 1:nreps){
results[rep,] <- sim(T0,J,alpha.sig,rho)
}
results.overall[r,] <- colMeans(results)
}
T0 <- 99
results.overall.ls <- matrix(NA,length(rho.vec),2)
for (r in 1:length(rho.vec)){
rho         <- rho.vec[r]
results.ls  <- matrix(NA,nreps,2)
for (rep in 1:nreps){
results.ls[rep,] <- sim(T0,J,alpha.sig,rho)
}
results.overall.ls[r,] <- colMeans(results.ls)
}
###########################################################################################################
# Figures
###########################################################################################################
graphics.off()
pdf("graphics/imposing_null_intro.pdf",pointsize=14,width=8.0,height=6.0)
plot(1, ylab="Empirical Rejection Probability", xlab="AR(1) Coefficient", main="", col="black", pch=".", xlim = range(0,1), ylim=c(0,0.5))
lines(rho.vec,results.overall[,1],col="black",lwd=3,lty=1,type="b",pch=1)
lines(rho.vec,results.overall[,2],col="black",lwd=3,lty=1,type="b",pch=2)
abline(h=0.1,col="black",lty=2,lwd=1)
legend("topleft",legend=c("Imposing the null hypothesis","Not imposing the null hypothesis"), seg.len=2, col=c("black","black"),fill=NA,border=NA, lty=c(1,1),lwd=c(3,3),pch=c(1,2), merge=T,bty="n")
graphics.off()
pdf("graphics/imposing_null_comparison.pdf",pointsize=14,width=8.0,height=6.0)
plot(1, ylab="Empirical Rejection Probability", xlab="AR(1) Coefficient", main="", col="black", pch=".", xlim = range(0,1), ylim=c(0,0.5))
lines(rho.vec,results.overall[,1],col="black",lwd=3,lty=1,type="b",pch=1)
lines(rho.vec,results.overall[,2],col="black",lwd=3,lty=1,type="b",pch=2)
lines(rho.vec,results.overall.ls[,1],col="black",lwd=3,lty=1,type="b",pch=3)
lines(rho.vec,results.overall.ls[,2],col="black",lwd=3,lty=1,type="b",pch=4)
abline(h=0.1,col="black",lty=2,lwd=1)
legend("topleft",legend=c("Imposing the null hypothesis (T=20)","Not imposing the null hypothesis (T=20)","Imposing the null hypothesis (T=100)","Not imposing the null hypothesis (T=100)"), seg.len=2, col=c("black","black","black","black"),fill=NA,border=NA, lty=c(1,1,1,1),lwd=c(3,3,3,3),pch=c(1,2,3,4), merge=T,bty="n")
graphics.off()
###########################################################################################################
# Application: Cunningham and Shah (2018, Review of Economic Studies)
# Paper: An exact and robust conformal inference approach for counterfactual and synthetic controls
# Authors: V. Chernozhukov, K. Wuthrich, Y. Zhu
# DISCLAIMER: This software is provided "as is" without warranty of any kind, expressed or implied.
# Questions/error reports: kwuthrich@ucsd.edu
###########################################################################################################
###########################################################################################################
# Preliminaries
###########################################################################################################
rm(list = ls())
setwd("/Users/kasparwuthrich/Dropbox/research/SC/SC with Victor and Yinchu/Conformal Paper/Code/replication_package_final")
set.seed(12345)
### Packages
library(xtable)
library(plotrix)
### Functions
source("functions_conformal_final.R")
###########################################################################################################
# Analysis
###########################################################################################################
### Specify norm for test statistic
q_norm <- 1 # L_1 norm
### Data (obtained from Scott Cunningham and Manisha Shah)
logfemrate <- read.delim("logfemrate.txt", header=T)
# First column: RI; columns 2-51: controls
Y1go <- as.matrix(logfemrate[,1])
Y0go <- as.matrix(logfemrate[,2:ncol(logfemrate)])
# Check I: comparison to Table 1 in Cunningham&Shah (2018)
# data19992009 <- as.matrix(logfemrate[15:25,])
# c(mean(data19992009),sd(data19992009))
# dim(data19992009)
# Check II: comparison to Table 9 in Cunningham&Shah (2018)
# cbind(1985:2009,Y1go)
# Time periods
T0go  <- 19
T1go  <- 6
T01go <- T0go+T1go
# Raw data plots
time <- c(seq(1985,2009,1))
pdf("graphics/gonorrhoea_data_raw.pdf",pointsize=14,width=8.0,height=6.0)
plot(range(time),c(0,10), ylab="Log Female Gonorrhea per 100,000", xlab="Time", main="", type="n")
for (j in 1:dim(Y0go)[2]) lines(time,Y0go[,j],col="darkgrey",lwd=0.5,lty=1)
lines(time,Y1go,col="black",lwd=5)
abline(v=time[T0go]+0.5,col="darkgrey",lty=2,lwd=1.5)
legend("topleft",legend=c("Other U.S. States","Rhode Island"), seg.len=2, col=c("darkgrey","black"),fill=NA,border=NA, lty=c(1,1),lwd=c(0.5,5), merge=T,bty="n")
graphics.off()
### Placebo specification tests
sens.classo.mb <- sens.sc.mb <- sens.did.mb <- sens.classo.all <- sens.sc.all <- sens.did.all <- matrix(NA,3,1)
Y1pre <- Y1go[1:T0go]
Y0pre <- Y0go[1:T0go,]
for (t in 1:3){
sens.classo.mb[t,1]   <- moving.block.q(Y1pre,Y0pre,(T0go-t),t,"classo",q_norm)
sens.classo.all[t,1]  <- all.q(Y1pre,Y0pre,(T0go-t),t,"classo",10000,q_norm)
sens.sc.mb[t,1]       <- moving.block.q(Y1pre,Y0pre,(T0go-t),t,"sc",q_norm)
sens.sc.all[t,1]      <- all.q(Y1pre,Y0pre,(T0go-t),t,"sc",10000,q_norm)
sens.did.mb[t,1]      <- moving.block.q(Y1pre,Y0pre,(T0go-t),t,"did",q_norm)
sens.did.all[t,1]     <- all.q(Y1pre,Y0pre,(T0go-t),t,"did",10000,q_norm)
}
xtable(cbind(sens.did.mb[,1],sens.sc.mb[,1],sens.classo.mb[,1],sens.did.all[,1],sens.sc.all[,1],sens.classo.all[,1]))
### Residual plots pre-treatment period
r.pre.classo      <- classo(Y1pre,Y0pre,1)
r.pre.sc          <- sc(Y1pre,Y0pre)
u.hat.go.pre.did    <- did(Y1pre,Y0pre)
u.hat.go.pre.sc     <- r.pre.sc$u.hat
u.hat.go.pre.classo <- r.pre.classo$u.hat
pdf("graphics/gonorrhoea_resid_pre_did.pdf",pointsize=16,width=6.0,height=6.0)
plot(range(seq(1985,2003,1)),c(-1,1), ylab="Residuals Pre-Treatment Period", xlab="Time", main="Difference-in-Differences",type="n")
points(seq(1985,2003,1),u.hat.go.pre.did,col="black",pch=20, lwd=2)
abline(h=0,col="grey",lty=2,lwd=1)
graphics.off()
pdf("graphics/gonorrhoea_resid_pre_sc.pdf",pointsize=16,width=6.0,height=6.0)
plot(range(seq(1985,2003,1)),c(-1,1), ylab="Residuals Pre-Treatment Period", xlab="Time", main="Synthetic Control",type="n")
points(seq(1985,2003,1),u.hat.go.pre.sc,col="black",pch=20, lwd=2)
abline(h=0,col="grey",lty=2,lwd=1)
graphics.off()
pdf("graphics/gonorrhoea_resid_pre_classo.pdf",pointsize=16,width=6.0,height=6.0)
plot(range(seq(1985,2003,1)),c(-1,1), ylab="Residuals Pre-Treatment Period", xlab="Time", main="Constrained Lasso",type="n")
points(seq(1985,2003,1),u.hat.go.pre.classo,col="black",pch=20, lwd=2)
abline(h=0,col="grey",lty=2,lwd=1)
graphics.off()
### No effect
p.noeff.did.mb      <- moving.block.q(Y1go,Y0go,T0go,T1go,"did",q_norm)
p.noeff.sc.mb       <- moving.block.q(Y1go,Y0go,T0go,T1go,"sc",q_norm)
p.noeff.classo.mb   <- moving.block.q(Y1go,Y0go,T0go,T1go,"classo",q_norm)
p.noeff.did.all     <- all.q(Y1go,Y0go,T0go,T1go,"did",10000,q_norm)
p.noeff.sc.all      <- all.q(Y1go,Y0go,T0go,T1go,"sc",10000,q_norm)
p.noeff.classo.all  <- all.q(Y1go,Y0go,T0go,T1go,"classo",10000,q_norm)
xtable(cbind(p.noeff.did.mb,p.noeff.sc.mb,p.noeff.classo.mb,p.noeff.did.all,p.noeff.sc.all,p.noeff.classo.all))
### Pointwise CI
alpha <- 0.1
grid <- c(seq(-5,2,0.01))
vec.ci.classo <- vec.ci.sc <- vec.ci.did <- m.ci.classo <- m.ci.sc <- m.ci.did <- NULL
for (t in 1:T1go){
indices       <- c(1:T0go,T0go+t)
Y1ci          <- Y1go[indices]
Y0ci          <- Y0go[indices,]
ci.sc         <- ci(Y1ci,Y0ci,"sc",alpha,grid)
vec.ci.sc     <- rbind(vec.ci.sc,cbind((t+2003),ci.sc))
m.ci.sc       <- cbind(m.ci.sc,mean(ci.sc))
ci.classo     <- ci(Y1ci,Y0ci,"classo",alpha,grid)
vec.ci.classo <- rbind(vec.ci.classo,cbind((t+2003),ci.classo))
m.ci.classo   <- cbind(m.ci.classo,mean(ci.classo))
ci.did        <- ci(Y1ci,Y0ci,"did",alpha,grid)
vec.ci.did    <- rbind(vec.ci.did,cbind((t+2003),ci.did))
m.ci.did      <- cbind(m.ci.did,mean(ci.did))
}
time <- c(seq(2004,2009,1))
pdf("graphics/ci_gonorrhoea_classo.pdf", pointsize=16,width=6.0,height=6.0)
plot(vec.ci.classo[,1],vec.ci.classo[,2], ylab="Gap in Log Female Gonorrhea per 100,000", xlab="Years", main="", col="black", pch=".", xlim = c(2003,2010), ylim=c(-2,2))
title("Constrained Lasso")
abline(h=0,col="grey",lty=2,lwd=2)
points(time, m.ci.classo,pch=16,cex=0.8,col="black")
legend(2003,2,legend=c("90% Confidence Interval"), col="black", cex=1,lty=c(1), lwd=c(2.25), bty=("n"))
legend(2003+0.3,2,legend=c(""), cex=1, col=c("black"), pch=16, bty=("n"))
graphics.off()
pdf("graphics/ci_gonorrhoea_sc.pdf", pointsize=16,width=6.0,height=6.0)
plot(vec.ci.sc[,1],vec.ci.sc[,2], ylab="Gap in Log Female Gonorrhea per 100,000", xlab="Years", main="", col="black", pch=".", xlim = c(2003,2010), ylim=c(-2,2))
title("Synthetic Control")
abline(h=0,col="grey",lty=2,lwd=2)
points(time, m.ci.sc,pch=16,cex=0.8,col="black")
legend(2003,2,legend=c("90% Confidence Interval"), col="black", cex=1,lty=c(1), lwd=c(2.25), bty=("n"))
legend(2003+0.3,2,legend=c(""), cex=1, col=c("black"), pch=16, bty=("n"))
graphics.off()
pdf("graphics/ci_gonorrhoea_did.pdf", pointsize=16,width=6.0,height=6.0)
plot(vec.ci.did[,1],vec.ci.did[,2], ylab="Gap in Log Female Gonorrhea per 100,000", xlab="Years", main="", col="black", pch=".", xlim = c(2003,2010), ylim=c(-2,2))
title("Difference-in-Differences")
abline(h=0,col="grey",lty=2,lwd=2)
points(time, m.ci.did,pch=16,cex=0.8,col="black")
legend(2003,2,legend=c("90% Confidence Interval"), col="black", cex=1,lty=c(1), lwd=c(2.25), bty=("n"))
legend(2003+0.3,2,legend=c(""), cex=1, col=c("black"), pch=16, bty=("n"))
graphics.off()
### Robustness checks
# Generate indicators for units which get non-zero weight in pre-treatment period
ind.sc      <- abs(r.pre.sc$w.hat)>1e-5
ind.classo  <- abs(r.pre.classo$w.hat[-1])>1e-5
ind.joint   <- ind.sc + ind.classo > 0
id.nonzero  <- which(ind.joint==1)
# Obtain p-values excluding one of the important control units at the time
p.vec.mb <- p.vec.all <- matrix(NA,length(id.nonzero),3)
for (i in 1:length(id.nonzero)) {
ind             <- id.nonzero[i]
p.vec.mb[i,1]   <- moving.block.q(Y1go,Y0go[,-ind],T0go,T1go,"did",q_norm)
p.vec.mb[i,2]   <- moving.block.q(Y1go,Y0go[,-ind],T0go,T1go,"sc",q_norm)
p.vec.mb[i,3]   <- moving.block.q(Y1go,Y0go[,-ind],T0go,T1go,"classo",q_norm)
p.vec.all[i,1]  <- all.q(Y1go,Y0go[,-ind],T0go,T1go,"did",10000,q_norm)
p.vec.all[i,2]  <- all.q(Y1go,Y0go[,-ind],T0go,T1go,"sc",10000,q_norm)
p.vec.all[i,3]  <- all.q(Y1go,Y0go[,-ind],T0go,T1go,"classo",10000,q_norm)
}
# Plots
x <- c(rep(1,length(id.nonzero)),rep(2,length(id.nonzero)),rep(3,length(id.nonzero)))
pdf("graphics/robustness_mb.pdf", pointsize=14,width=6.0,height=6.0)
sizeplot(x,  c(p.vec.mb) , main="P-values, Moving Block Permutations", xlab="", ylab="p-value",xaxt='n',ylim=c(0,0.2))
axis(1, at=1:3, labels=c("DID","SC","CL"))
graphics.off()
pdf("graphics/robustness_iid.pdf", pointsize=14,width=6.0,height=6.0)
sizeplot(x,  c(p.vec.all) , main="P-values, iid Permutations", xlab="", ylab="p-value",xaxt='n',ylim=c(0,0.2))
axis(1, at=1:3, labels=c("DID","SC","CL"))
graphics.off()
